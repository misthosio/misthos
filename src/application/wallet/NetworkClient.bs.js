// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Network = require("./Network.bs.js");
var Belt_Set = require("bs-platform/lib/js/belt_Set.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var BitcoinjsLib = require("bitcoinjs-lib");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");
var BitcoindClient = require("./BitcoindClient.bs.js");
var BlockchainInfoClient = require("./BlockchainInfoClient.bs.js");
var BlockstreamInfoClient = require("./BlockstreamInfoClient.bs.js");

function WithFallback(ClientA) {
  return (function (ClientB) {
      var network = ClientA[/* network */0];
      var getUTXOs = function (addresses) {
        return Curry._1(ClientA[/* getUTXOs */1], addresses).then((function (utxos) {
                        return Curry._1(ClientB[/* getUTXOs */1], addresses).then((function (moreUtxos) {
                                        return Promise.resolve(Belt_Set.union(utxos, moreUtxos));
                                      })).catch((function (param) {
                                      return Promise.resolve(utxos);
                                    }));
                      })).catch((function (param) {
                      return Curry._1(ClientB[/* getUTXOs */1], addresses);
                    }));
      };
      var getTransactionInfo = function (txIds) {
        return Curry._1(ClientA[/* getTransactionInfo */2], txIds).then((function (txInfos) {
                        var match = Belt_List.size(txInfos) !== Belt_SetString.size(txIds);
                        if (match) {
                          return Curry._1(ClientB[/* getTransactionInfo */2], txIds);
                        } else {
                          return Promise.resolve(txInfos);
                        }
                      })).catch((function (param) {
                      return Curry._1(ClientB[/* getTransactionInfo */2], txIds);
                    }));
      };
      var getTransactionHex = function (txIds) {
        return Curry._1(ClientA[/* getTransactionHex */3], txIds).then((function (txHex) {
                        var match = txHex.length !== txIds.length;
                        if (match) {
                          return Curry._1(ClientB[/* getTransactionHex */3], txIds);
                        } else {
                          return Promise.resolve(txHex);
                        }
                      })).catch((function (param) {
                      return Curry._1(ClientB[/* getTransactionHex */3], txIds);
                    }));
      };
      var getCurrentBlockHeight = function (param) {
        return Curry._1(ClientA[/* getCurrentBlockHeight */4], /* () */0).catch((function (param) {
                      return Curry._1(ClientB[/* getCurrentBlockHeight */4], /* () */0);
                    }));
      };
      var broadcastTransaction = function (tx) {
        return Curry._1(ClientA[/* broadcastTransaction */5], tx).then((function (param) {
                        if (typeof param === "number" || param.tag) {
                          return Curry._1(ClientB[/* broadcastTransaction */5], tx);
                        } else {
                          return Promise.resolve(/* Ok */Block.__(0, [param[0]]));
                        }
                      })).catch((function (param) {
                      return Curry._1(ClientB[/* broadcastTransaction */5], tx);
                    }));
      };
      return /* module */[
              /* network */network,
              /* getUTXOs */getUTXOs,
              /* getTransactionInfo */getTransactionInfo,
              /* getTransactionHex */getTransactionHex,
              /* getCurrentBlockHeight */getCurrentBlockHeight,
              /* broadcastTransaction */broadcastTransaction
            ];
    });
}

function Make(Client) {
  var network = Client[/* network */0];
  var transactionInfo = Client[/* getTransactionInfo */2];
  var transactionHex = Client[/* getTransactionHex */3];
  var currentBlockHeight = Client[/* getCurrentBlockHeight */4];
  var transactionInputs = function (addresses) {
    return Curry._1(Client[/* getUTXOs */1], Belt_List.fromArray(Belt_MapString.keysToArray(addresses))).then((function (utxos) {
                  return Promise.resolve(Belt_Set.reduceU(utxos, Network.inputSet(/* () */0), (function (res, param) {
                                    var address = param[/* address */2];
                                    var a = Js_option.getExn(Belt_MapString.get(addresses, address));
                                    return Belt_Set.add(res, /* record */[
                                                /* txId */param[/* txId */0],
                                                /* txOutputN */param[/* txOutputN */1],
                                                /* address */address,
                                                /* value */param[/* amount */3],
                                                /* nCoSigners */a[/* nCoSigners */0],
                                                /* nPubKeys */a[/* nPubKeys */1],
                                                /* coordinates */a[/* coordinates */2],
                                                /* sequence */a[/* sequence */6],
                                                /* unlocked */false
                                              ]);
                                  })));
                }));
  };
  var broadcastTransaction = Client[/* broadcastTransaction */5];
  return /* module */[
          /* network */network,
          /* transactionInfo */transactionInfo,
          /* transactionHex */transactionHex,
          /* currentBlockHeight */currentBlockHeight,
          /* transactionInputs */transactionInputs,
          /* broadcastTransaction */broadcastTransaction
        ];
}

var Client = BitcoindClient.make(/* record */[
      /* bitcoindUrl */"http://localhost:18322",
      /* rpcUser */"bitcoin",
      /* rpcPassword */"bitcoin"
    ], BitcoinjsLib.networks.testnet);

var network = Client[/* network */0];

var transactionInfo = Client[/* getTransactionInfo */2];

var transactionHex = Client[/* getTransactionHex */3];

var currentBlockHeight = Client[/* getCurrentBlockHeight */4];

function transactionInputs(addresses) {
  return Curry._1(Client[/* getUTXOs */1], Belt_List.fromArray(Belt_MapString.keysToArray(addresses))).then((function (utxos) {
                return Promise.resolve(Belt_Set.reduceU(utxos, Network.inputSet(/* () */0), (function (res, param) {
                                  var address = param[/* address */2];
                                  var a = Js_option.getExn(Belt_MapString.get(addresses, address));
                                  return Belt_Set.add(res, /* record */[
                                              /* txId */param[/* txId */0],
                                              /* txOutputN */param[/* txOutputN */1],
                                              /* address */address,
                                              /* value */param[/* amount */3],
                                              /* nCoSigners */a[/* nCoSigners */0],
                                              /* nPubKeys */a[/* nPubKeys */1],
                                              /* coordinates */a[/* coordinates */2],
                                              /* sequence */a[/* sequence */6],
                                              /* unlocked */false
                                            ]);
                                })));
              }));
}

var broadcastTransaction = Client[/* broadcastTransaction */5];

var Regtest = /* module */[
  /* network */network,
  /* transactionInfo */transactionInfo,
  /* transactionHex */transactionHex,
  /* currentBlockHeight */currentBlockHeight,
  /* transactionInputs */transactionInputs,
  /* broadcastTransaction */broadcastTransaction
];

var Client$1 = BlockstreamInfoClient.make(BlockstreamInfoClient.testnetConfig, BitcoinjsLib.networks.testnet);

var network$1 = Client$1[/* network */0];

var transactionInfo$1 = Client$1[/* getTransactionInfo */2];

var transactionHex$1 = Client$1[/* getTransactionHex */3];

var currentBlockHeight$1 = Client$1[/* getCurrentBlockHeight */4];

function transactionInputs$1(addresses) {
  return Curry._1(Client$1[/* getUTXOs */1], Belt_List.fromArray(Belt_MapString.keysToArray(addresses))).then((function (utxos) {
                return Promise.resolve(Belt_Set.reduceU(utxos, Network.inputSet(/* () */0), (function (res, param) {
                                  var address = param[/* address */2];
                                  var a = Js_option.getExn(Belt_MapString.get(addresses, address));
                                  return Belt_Set.add(res, /* record */[
                                              /* txId */param[/* txId */0],
                                              /* txOutputN */param[/* txOutputN */1],
                                              /* address */address,
                                              /* value */param[/* amount */3],
                                              /* nCoSigners */a[/* nCoSigners */0],
                                              /* nPubKeys */a[/* nPubKeys */1],
                                              /* coordinates */a[/* coordinates */2],
                                              /* sequence */a[/* sequence */6],
                                              /* unlocked */false
                                            ]);
                                })));
              }));
}

var broadcastTransaction$1 = Client$1[/* broadcastTransaction */5];

var Testnet = /* module */[
  /* network */network$1,
  /* transactionInfo */transactionInfo$1,
  /* transactionHex */transactionHex$1,
  /* currentBlockHeight */currentBlockHeight$1,
  /* transactionInputs */transactionInputs$1,
  /* broadcastTransaction */broadcastTransaction$1
];

var ClientA = BlockstreamInfoClient.make(BlockstreamInfoClient.mainnetConfig, BitcoinjsLib.networks.bitcoin);

var Client$2 = (function (ClientB) {
      var network = ClientA[/* network */0];
      var getUTXOs = function (addresses) {
        return Curry._1(ClientA[/* getUTXOs */1], addresses).then((function (utxos) {
                        return Curry._1(ClientB[/* getUTXOs */1], addresses).then((function (moreUtxos) {
                                        return Promise.resolve(Belt_Set.union(utxos, moreUtxos));
                                      })).catch((function (param) {
                                      return Promise.resolve(utxos);
                                    }));
                      })).catch((function (param) {
                      return Curry._1(ClientB[/* getUTXOs */1], addresses);
                    }));
      };
      var getTransactionInfo = function (txIds) {
        return Curry._1(ClientA[/* getTransactionInfo */2], txIds).then((function (txInfos) {
                        var match = Belt_List.size(txInfos) !== Belt_SetString.size(txIds);
                        if (match) {
                          return Curry._1(ClientB[/* getTransactionInfo */2], txIds);
                        } else {
                          return Promise.resolve(txInfos);
                        }
                      })).catch((function (param) {
                      return Curry._1(ClientB[/* getTransactionInfo */2], txIds);
                    }));
      };
      var getTransactionHex = function (txIds) {
        return Curry._1(ClientA[/* getTransactionHex */3], txIds).then((function (txHex) {
                        var match = txHex.length !== txIds.length;
                        if (match) {
                          return Curry._1(ClientB[/* getTransactionHex */3], txIds);
                        } else {
                          return Promise.resolve(txHex);
                        }
                      })).catch((function (param) {
                      return Curry._1(ClientB[/* getTransactionHex */3], txIds);
                    }));
      };
      var getCurrentBlockHeight = function (param) {
        return Curry._1(ClientA[/* getCurrentBlockHeight */4], /* () */0).catch((function (param) {
                      return Curry._1(ClientB[/* getCurrentBlockHeight */4], /* () */0);
                    }));
      };
      var broadcastTransaction = function (tx) {
        return Curry._1(ClientA[/* broadcastTransaction */5], tx).then((function (param) {
                        if (typeof param === "number" || param.tag) {
                          return Curry._1(ClientB[/* broadcastTransaction */5], tx);
                        } else {
                          return Promise.resolve(/* Ok */Block.__(0, [param[0]]));
                        }
                      })).catch((function (param) {
                      return Curry._1(ClientB[/* broadcastTransaction */5], tx);
                    }));
      };
      return /* module */[
              /* network */network,
              /* getUTXOs */getUTXOs,
              /* getTransactionInfo */getTransactionInfo,
              /* getTransactionHex */getTransactionHex,
              /* getCurrentBlockHeight */getCurrentBlockHeight,
              /* broadcastTransaction */broadcastTransaction
            ];
    })(BlockchainInfoClient.make(BlockchainInfoClient.mainnetConfig, BitcoinjsLib.networks.bitcoin));

var network$2 = Client$2[/* network */0];

var transactionInfo$2 = Client$2[/* getTransactionInfo */2];

var transactionHex$2 = Client$2[/* getTransactionHex */3];

var currentBlockHeight$2 = Client$2[/* getCurrentBlockHeight */4];

function transactionInputs$2(addresses) {
  return Curry._1(Client$2[/* getUTXOs */1], Belt_List.fromArray(Belt_MapString.keysToArray(addresses))).then((function (utxos) {
                return Promise.resolve(Belt_Set.reduceU(utxos, Network.inputSet(/* () */0), (function (res, param) {
                                  var address = param[/* address */2];
                                  var a = Js_option.getExn(Belt_MapString.get(addresses, address));
                                  return Belt_Set.add(res, /* record */[
                                              /* txId */param[/* txId */0],
                                              /* txOutputN */param[/* txOutputN */1],
                                              /* address */address,
                                              /* value */param[/* amount */3],
                                              /* nCoSigners */a[/* nCoSigners */0],
                                              /* nPubKeys */a[/* nPubKeys */1],
                                              /* coordinates */a[/* coordinates */2],
                                              /* sequence */a[/* sequence */6],
                                              /* unlocked */false
                                            ]);
                                })));
              }));
}

var broadcastTransaction$2 = Client$2[/* broadcastTransaction */5];

var Mainnet = /* module */[
  /* network */network$2,
  /* transactionInfo */transactionInfo$2,
  /* transactionHex */transactionHex$2,
  /* currentBlockHeight */currentBlockHeight$2,
  /* transactionInputs */transactionInputs$2,
  /* broadcastTransaction */broadcastTransaction$2
];

function transactionInputs$3(param) {
  switch (param) {
    case 0 : 
        return transactionInputs;
    case 1 : 
        return transactionInputs$1;
    case 2 : 
        return transactionInputs$2;
    
  }
}

function transactionInfo$3(param) {
  switch (param) {
    case 0 : 
        return transactionInfo;
    case 1 : 
        return transactionInfo$1;
    case 2 : 
        return transactionInfo$2;
    
  }
}

function transactionHex$3(param) {
  switch (param) {
    case 0 : 
        return transactionHex;
    case 1 : 
        return transactionHex$1;
    case 2 : 
        return transactionHex$2;
    
  }
}

function currentBlockHeight$3(param) {
  switch (param) {
    case 0 : 
        return currentBlockHeight;
    case 1 : 
        return currentBlockHeight$1;
    case 2 : 
        return currentBlockHeight$2;
    
  }
}

function broadcastTransaction$3(param) {
  switch (param) {
    case 0 : 
        return broadcastTransaction;
    case 1 : 
        return broadcastTransaction$1;
    case 2 : 
        return broadcastTransaction$2;
    
  }
}

exports.WithFallback = WithFallback;
exports.Make = Make;
exports.Regtest = Regtest;
exports.Testnet = Testnet;
exports.Mainnet = Mainnet;
exports.transactionInputs = transactionInputs$3;
exports.transactionInfo = transactionInfo$3;
exports.transactionHex = transactionHex$3;
exports.currentBlockHeight = currentBlockHeight$3;
exports.broadcastTransaction = broadcastTransaction$3;
/* Client Not a pure module */
