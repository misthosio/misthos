// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var BTC = require("./BTC.bs.js");
var Json = require("@glennsl/bs-json/src/Json.bs.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Fetch = require("bs-fetch/src/Fetch.js");
var Belt_Set = require("bs-platform/lib/js/belt_Set.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var WalletTypes = require("./WalletTypes.bs.js");

function makeAuthHeaders(param) {
  var authString = Buffer.from("" + (String(param[/* rpcUser */1]) + (":" + (String(param[/* rpcPassword */2]) + "")))).toString("base64");
  return {
          Authorization: "Basic " + (String(authString) + "")
        };
}

function rpcCall(config, jsonRPC) {
  return fetch(config[/* bitcoindUrl */0], Fetch.RequestInit[/* make */0](/* Post */2, Caml_option.some(makeAuthHeaders(config)), Caml_option.some(jsonRPC), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(/* () */0)).then((function (prim) {
                return prim.json();
              }));
}

function importAllAs(config, addresses, label) {
  if (addresses) {
    var jsonRPCImport = Json.stringify(Json_encode.object_(/* :: */[
              /* tuple */[
                "jsonrpc",
                "1.0"
              ],
              /* :: */[
                /* tuple */[
                  "method",
                  "importaddress"
                ],
                /* :: */[
                  /* tuple */[
                    "params",
                    Json_encode.list((function (prim) {
                            return prim;
                          }), /* :: */[
                          addresses[0],
                          /* :: */[
                            label,
                            /* [] */0
                          ]
                        ])
                  ],
                  /* [] */0
                ]
              ]
            ]));
    var start = rpcCall(config, jsonRPCImport);
    return List.fold_left((function (p, address) {
                    return p.then((function (_r) {
                                  var jsonRPCImport = Json.stringify(Json_encode.object_(/* :: */[
                                            /* tuple */[
                                              "jsonrpc",
                                              "1.0"
                                            ],
                                            /* :: */[
                                              /* tuple */[
                                                "method",
                                                "importaddress"
                                              ],
                                              /* :: */[
                                                /* tuple */[
                                                  "params",
                                                  Json_encode.list((function (prim) {
                                                          return prim;
                                                        }), /* :: */[
                                                        address,
                                                        /* :: */[
                                                          label,
                                                          /* [] */0
                                                        ]
                                                      ])
                                                ],
                                                /* [] */0
                                              ]
                                            ]
                                          ]));
                                  return rpcCall(config, jsonRPCImport);
                                }));
                  }), start, addresses[1]).then((function (param) {
                  return Promise.resolve(/* () */0);
                }));
  } else {
    return Promise.resolve(/* () */0);
  }
}

function getUTXOs(config, addresses) {
  return importAllAs(config, addresses, "").then((function (param) {
                  var jsonRPCUnspent = Json.stringify(Json_encode.object_(/* :: */[
                            /* tuple */[
                              "jsonrpc",
                              "1.0"
                            ],
                            /* :: */[
                              /* tuple */[
                                "method",
                                "listunspent"
                              ],
                              /* :: */[
                                /* tuple */[
                                  "params",
                                  Json_encode.tuple3((function (prim) {
                                          return prim;
                                        }), (function (prim) {
                                          return prim;
                                        }), (function (param) {
                                          return Json_encode.list((function (prim) {
                                                        return prim;
                                                      }), param);
                                        }), /* tuple */[
                                        1,
                                        9999999,
                                        addresses
                                      ])
                                ],
                                /* [] */0
                              ]
                            ]
                          ]));
                  return rpcCall(config, jsonRPCUnspent);
                })).then((function (obj) {
                return Promise.resolve(Belt_Set.mergeMany(WalletTypes.emptyUtxoSet, Belt_List.toArray(Json_decode.field("result", (function (param) {
                                          return Json_decode.withDefault(/* [] */0, (function (param) {
                                                        return Json_decode.list((function (utxo) {
                                                                      return /* record */[
                                                                              /* txId */Json_decode.field("txid", Json_decode.string, utxo),
                                                                              /* txOutputN */Json_decode.field("vout", Json_decode.$$int, utxo),
                                                                              /* address */Json_decode.field("address", Json_decode.string, utxo),
                                                                              /* amount */BTC.fromFloat(Json_decode.field("amount", Json_decode.$$float, utxo))
                                                                            ];
                                                                    }), param);
                                                      }), param);
                                        }), obj))));
              }));
}

function broadcastTransaction(config, transaction) {
  var jsonRPC = Json.stringify(Json_encode.object_(/* :: */[
            /* tuple */[
              "jsonrpc",
              "1.0"
            ],
            /* :: */[
              /* tuple */[
                "method",
                "sendrawtransaction"
              ],
              /* :: */[
                /* tuple */[
                  "params",
                  Json_encode.list((function (prim) {
                          return prim;
                        }), /* :: */[
                        transaction.toHex(),
                        /* [] */0
                      ])
                ],
                /* [] */0
              ]
            ]
          ]));
  return rpcCall(config, jsonRPC).then((function (res) {
                var err = Json_decode.field("error", (function (param) {
                        return Json_decode.optional((function (param) {
                                      return Json_decode.field("message", Json_decode.string, param);
                                    }), param);
                      }), res);
                return Promise.resolve(err !== undefined ? /* Error */Block.__(1, [err]) : /* Ok */Block.__(0, [Json_decode.field("result", Json_decode.string, res)]));
              }));
}

function make(config, network) {
  var getUTXOs$1 = function (param) {
    return getUTXOs(config, param);
  };
  var getTransactionInfo = function (param) {
    return Promise.resolve(/* [] */0);
  };
  var getTransactionHex = function (param) {
    return Promise.resolve(/* array */[]);
  };
  var getCurrentBlockHeight = function (param) {
    return Promise.resolve(1);
  };
  var broadcastTransaction$1 = function (param) {
    return broadcastTransaction(config, param);
  };
  return /* module */[
          /* network */network,
          /* getUTXOs */getUTXOs$1,
          /* getTransactionInfo */getTransactionInfo,
          /* getTransactionHex */getTransactionHex,
          /* getCurrentBlockHeight */getCurrentBlockHeight,
          /* broadcastTransaction */broadcastTransaction$1
        ];
}

var satoshisPerBTC = 1e8;

var float_ = Json_decode.$$float;

exports.satoshisPerBTC = satoshisPerBTC;
exports.float_ = float_;
exports.makeAuthHeaders = makeAuthHeaders;
exports.rpcCall = rpcCall;
exports.importAllAs = importAllAs;
exports.getUTXOs = getUTXOs;
exports.broadcastTransaction = broadcastTransaction;
exports.make = make;
/* BTC Not a pure module */
