// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var BTC = require("./BTC.bs.js");
var Block = require("bs-platform/lib/js/block.js");
var Fetch = require("bs-fetch/src/Fetch.js");
var Belt_Set = require("bs-platform/lib/js/belt_Set.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var WalletTypes = require("./WalletTypes.bs.js");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");

function decodeUTXO(address, raw) {
  return /* record */[
          /* txId */Json_decode.field("txid", Json_decode.string, raw),
          /* txOutputN */Json_decode.field("vout", Json_decode.$$int, raw),
          /* address */address,
          /* amount */BTC.fromSatoshisFloat(Json_decode.field("value", Json_decode.$$float, raw))
        ];
}

function decodeUTXOs(address, raw) {
  return Json_decode.withDefault(/* [] */0, (function (param) {
                return Json_decode.list((function (param) {
                              return decodeUTXO(address, param);
                            }), param);
              }), raw);
}

function getUTXOs(config, addresses) {
  if (addresses) {
    return Promise.all(Belt_List.toArray(Belt_List.map(addresses, (function (address) {
                            return fetch(config[/* url */0] + ("/address/" + (address + "/utxo"))).then((function (prim) {
                                            return prim.json();
                                          })).then((function (raw) {
                                          return Promise.resolve(decodeUTXOs(address, raw));
                                        }));
                          })))).then((function (results) {
                  return Promise.resolve(Belt_Array.reduce(results, WalletTypes.emptyUtxoSet, (function (res, utxos) {
                                    return Belt_Set.mergeMany(res, Belt_List.toArray(utxos));
                                  })));
                }));
  } else {
    return Promise.resolve(WalletTypes.emptyUtxoSet);
  }
}

function getTransactionInfo(config, transactions) {
  return Promise.all(Belt_List.toArray(Belt_SetString.reduceU(transactions, /* [] */0, (function (res, txId) {
                          return /* :: */[
                                  fetch(config[/* url */0] + ("/tx/" + txId)).then((function (prim) {
                                              return prim.json();
                                            })).then((function (raw) {
                                            return Promise.resolve(/* record */[
                                                        /* txId */txId,
                                                        /* blockHeight */Json_decode.field("status", (function (param) {
                                                                return Json_decode.optional((function (param) {
                                                                              return Json_decode.field("block_height", Json_decode.$$float, param);
                                                                            }), param);
                                                              }), raw),
                                                        /* unixTime */Json_decode.field("status", (function (param) {
                                                                return Json_decode.optional((function (param) {
                                                                              return Json_decode.field("block_time", Json_decode.$$float, param);
                                                                            }), param);
                                                              }), raw)
                                                      ]);
                                          })).catch((function (param) {
                                          return Promise.resolve(undefined);
                                        })),
                                  res
                                ];
                        })))).then((function (res) {
                return Promise.resolve(Belt_List.fromArray(Belt_Array.keepMap(res, (function (res) {
                                      return res;
                                    }))));
              }));
}

function getCurrentBlockHeight(config, param) {
  return fetch(config[/* url */0] + "/blocks/tip/height").then((function (prim) {
                  return prim.json();
                })).then((function (res) {
                return Promise.resolve(Json_decode.$$int(res));
              }));
}

function getTransactionHex(config, transactions) {
  return Promise.all(Belt_Array.mapU(transactions, (function (txId) {
                    return fetch(config[/* url */0] + ("/tx/" + (txId + "/hex"))).then((function (prim) {
                                    return prim.text();
                                  })).then((function (hex) {
                                  return Promise.resolve(/* tuple */[
                                              txId,
                                              hex
                                            ]);
                                }));
                  })));
}

function broadcastTransaction(config, transaction) {
  var txHex = transaction.toHex();
  var txId = transaction.getId();
  return fetch(config[/* url */0] + "/tx", Fetch.RequestInit[/* make */0](/* Post */2, undefined, Caml_option.some(txHex), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(/* () */0)).then((function (prim) {
                    return prim.text();
                  })).then((function (res) {
                  if (res === txId) {
                    return Promise.resolve(/* Ok */Block.__(0, [txId]));
                  } else {
                    return Promise.resolve(/* Error */Block.__(1, [res]));
                  }
                })).catch((function (err) {
                return Promise.resolve(/* FetchError */Block.__(2, [err]));
              }));
}

function make(config, network) {
  var getUTXOs$1 = function (param) {
    return getUTXOs(config, param);
  };
  var getTransactionInfo$1 = function (param) {
    return getTransactionInfo(config, param);
  };
  var getTransactionHex$1 = function (param) {
    return getTransactionHex(config, param);
  };
  var getCurrentBlockHeight$1 = function (param) {
    return getCurrentBlockHeight(config, param);
  };
  var broadcastTransaction$1 = function (param) {
    return broadcastTransaction(config, param);
  };
  return /* module */[
          /* network */network,
          /* getUTXOs */getUTXOs$1,
          /* getTransactionInfo */getTransactionInfo$1,
          /* getTransactionHex */getTransactionHex$1,
          /* getCurrentBlockHeight */getCurrentBlockHeight$1,
          /* broadcastTransaction */broadcastTransaction$1
        ];
}

var testnetConfig = /* record */[/* url */"https://blockstream.info/testnet/api"];

var mainnetConfig = /* record */[/* url */"https://blockstream.info/api"];

var float_ = Json_decode.$$float;

exports.testnetConfig = testnetConfig;
exports.mainnetConfig = mainnetConfig;
exports.float_ = float_;
exports.decodeUTXO = decodeUTXO;
exports.decodeUTXOs = decodeUTXOs;
exports.getUTXOs = getUTXOs;
exports.getTransactionInfo = getTransactionInfo;
exports.getCurrentBlockHeight = getCurrentBlockHeight;
exports.getTransactionHex = getTransactionHex;
exports.broadcastTransaction = broadcastTransaction;
exports.make = make;
/* BTC Not a pure module */
